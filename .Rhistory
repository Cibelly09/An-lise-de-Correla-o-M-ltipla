k <- 3
kmeans_obs <- kmeans(df_obs[, c("Axis1","Axis2")], centers = k, nstart = 25)
# adiciona coluna Cluster
df_obs$Cluster <- factor(kmeans_obs$cluster)
# salva a base clusterizada
if(!dir.exists("output")) dir.create("output")
write.csv(df_obs, "output/obs_clusterizado.csv", row.names = FALSE)
# ----- 3) Composi√ß√£o por TIPO DE DEFICI√äNCIA (percentual dentro de cada cluster) -----
# ajusta nome da coluna caso seja diferente
tipo_var <- "DS_TIPO_DEFICIENCIA"   # se for outro nome, altera aqui
library(scales)
df_cluster_tipo <- df_obs %>%
group_by(Cluster, !!sym(tipo_var)) %>%
summarise(Qtd = n(), .groups = "drop") %>%
group_by(Cluster) %>%
mutate(Percent = Qtd / sum(Qtd)) %>%
ungroup()
# plot (barras empilhadas em propor√ß√£o)
g_tipo <- ggplot(df_cluster_tipo, aes(x = Cluster, y = Percent, fill = !!sym(tipo_var))) +
geom_bar(stat = "identity", position = "fill") +
scale_y_continuous(labels = percent_format(accuracy = 1)) +
labs(title = "Composi√ß√£o dos Clusters por Tipo de Defici√™ncia",
x = "Cluster", y = "Propor√ß√£o dentro do Cluster", fill = "Tipo de Defici√™ncia") +
theme_minimal(base_size = 13)
print(g_tipo)
ggsave("output/cluster_por_tipo_deficiencia.png", g_tipo, width = 9, height = 5, dpi = 300)
# ----- 4) Composi√ß√£o por ESTADO (UF) -----
uf_var <- "SG_UF"
df_cluster_uf <- df_obs %>%
group_by(Cluster, !!sym(uf_var)) %>%
summarise(Qtd = n(), .groups = "drop") %>%
group_by(Cluster) %>%
mutate(Percent = Qtd / sum(Qtd)) %>%
ungroup()
g_uf <- ggplot(df_cluster_uf, aes(x = Cluster, y = Percent, fill = !!sym(uf_var))) +
geom_bar(stat = "identity", position = "fill") +
scale_y_continuous(labels = percent_format(accuracy = 1)) +
labs(title = "Composi√ß√£o dos Clusters por Estado (UF)",
x = "Cluster", y = "Propor√ß√£o dentro do Cluster", fill = "Estado (UF)") +
theme_minimal(base_size = 13)
print(g_uf)
ggsave("output/cluster_por_uf.png", g_uf, width = 10, height = 6, dpi = 300)
# ----- 5) Tabelas resumo para interpretar rapidamente -----
tab_tipo <- df_cluster_tipo %>%
arrange(Cluster, desc(Percent)) %>%
mutate(Percent = scales::percent(Percent, accuracy = 0.1))
tab_uf <- df_cluster_uf %>%
arrange(Cluster, desc(Percent)) %>%
mutate(Percent = scales::percent(Percent, accuracy = 0.1))
write.csv(tab_tipo, "output/resumo_cluster_tipo.csv", row.names = FALSE)
write.csv(tab_uf, "output/resumo_cluster_uf.csv", row.names = FALSE)
# imprime as top 3 categorias por cluster (exemplo)
top_tipo <- tab_tipo %>% group_by(Cluster) %>% slice_max(order_by = as.numeric(gsub("%","",Percent)), n = 3)
print(top_tipo)
top_uf <- tab_uf %>% group_by(Cluster) %>% slice_max(order_by = as.numeric(gsub("%","",Percent)), n = 5)
print(top_uf)
# Se a vari√°vel REGIAO ainda n√£o existe:
# Cria coluna de regi√£o a partir da UF
df_obs <- df_obs %>%
mutate(REGIAO = case_when(
SG_UF %in% c("AC", "AM", "AP", "PA", "RO", "RR", "TO") ~ "Norte",
SG_UF %in% c("AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE") ~ "Nordeste",
SG_UF %in% c("DF", "GO", "MT", "MS") ~ "Centro-Oeste",
SG_UF %in% c("ES", "MG", "RJ", "SP") ~ "Sudeste",
SG_UF %in% c("PR", "RS", "SC") ~ "Sul",
TRUE ~ "Outros"
))
# ----- Composi√ß√£o dos clusters por REGI√ÉO -----
df_cluster_regiao <- df_obs %>%
group_by(Cluster, REGIAO) %>%
summarise(Qtd = n(), .groups = "drop") %>%
group_by(Cluster) %>%
mutate(Percent = Qtd / sum(Qtd)) %>%
ungroup()
# Gr√°fico
g_regiao <- ggplot(df_cluster_regiao, aes(x = Cluster, y = Percent, fill = REGIAO)) +
geom_bar(stat = "identity", position = "fill") +
scale_y_continuous(labels = percent_format(accuracy = 1)) +
labs(
title = "Composi√ß√£o dos Clusters por Regi√£o",
x = "Cluster", y = "Propor√ß√£o dentro do Cluster",
fill = "Regi√£o"
) +
theme_minimal(base_size = 13)
print(g_regiao)
# Salva a imagem
ggsave("output/cluster_por_regiao.png", g_regiao, width = 9, height = 5, dpi = 300)
library(tidyr)
# Resumo por REGI√ÉO
tab_regiao <- df_obs %>%
group_by(Cluster, REGIAO) %>%
summarise(Qtd = n(), .groups = "drop") %>%
group_by(Cluster) %>%
mutate(Percent = Qtd / sum(Qtd)) %>%
arrange(Cluster, desc(Percent)) %>%
mutate(Percent = percent(Percent, accuracy = 0.1)) %>%
slice_head(n = 2) %>%  # pega as 2 regi√µes predominantes de cada cluster
summarise(
Regiao_Predominante = paste(REGIAO, collapse = ", "),
Percentual = paste(Percent, collapse = " / "),
.groups = "drop"
)
# Resumo por TIPO DE DEFICI√äNCIA
tab_def <- df_obs %>%
group_by(Cluster, DS_TIPO_DEFICIENCIA) %>%
summarise(Qtd = n(), .groups = "drop") %>%
group_by(Cluster) %>%
mutate(Percent = Qtd / sum(Qtd)) %>%
arrange(Cluster, desc(Percent)) %>%
mutate(Percent = percent(Percent, accuracy = 0.1)) %>%
slice_head(n = 2) %>%  # pega os 2 tipos predominantes
summarise(
Tipo_Def_Predominante = paste(DS_TIPO_DEFICIENCIA, collapse = ", "),
Percentual_Def = paste(Percent, collapse = " / "),
.groups = "drop"
)
# Junta as duas tabelas
tabela_resumo <- left_join(tab_regiao, tab_def, by = "Cluster")
# Exibe
print(tabela_resumo)
# Salva para Excel/CSV
write.csv(tabela_resumo, "output/resumo_clusters.csv", row.names = FALSE)
resumo_texto <- "
## üìä Segmenta√ß√£o Regional e Perfil dos Clusters
A an√°lise de clusters revelou quatro grupos principais de eleitores com defici√™ncia no Brasil:
- **Cluster 1 ‚Äì Sudeste/Centro-Oeste:** Defici√™ncia de locomo√ß√£o, perfil urbano e envelhecido.
- **Cluster 2 ‚Äì Sudeste/Nordeste:** Distribui√ß√£o mista, marcada por desigualdade regional.
- **Cluster 3 ‚Äì Norte/Nordeste:** Defici√™ncia visual, maior vulnerabilidade social.
- **Cluster 4 ‚Äì Sul:** Defici√™ncia auditiva, maior homogeneidade e melhor estrutura de diagn√≥stico.
Esses resultados refor√ßam como as **condi√ß√µes regionais e o tipo de defici√™ncia est√£o interligados**, indicando que pol√≠ticas de acessibilidade e inclus√£o devem ser **regionalmente direcionadas**.
"
# Caminho do README
arquivo_readme <- "README.md"
# Adiciona o texto no final do README
cat(resumo_texto, file = arquivo_readme, append = TRUE, sep = "\n")
# Confirma
cat("Resumo anal√≠tico adicionado ao README com sucesso ‚úÖ\n")
ggplot(df_ACM, aes(x=CS1, y=CS2, color = Cluster, label = Vari√°vel)) +
geom_point(size = 4, alpha = 0.8) +
geom_label_repel(size = 3, show.legend = FALSE) +
geom_vline(xintercept = 0, linetype = "dashed", color = "gray60")+
geom_hline(yintercept = 0, linetype = "dashed", color = "gray60")+
labs(
title = "Mapa Perceptual - Segmenta√ß√£o dos Perfis de Eleitores com Defici√™ncia",
subtitle = "An√°lise de Correspond√™ncia M√∫ltipla (ACM) com K-Means Clustering",
x = paste("Dimens√£o 1:", round(perc_variancia[1],2), "%"),
y = paste("Dimens√£o 2:", round(perc_variancia[2],2), "%"),
color = "Cluster"
) +
theme_bw() +
theme(plot.title = element_text(size=14,face="bold"),
plot.subtitle = element_text(size =12),
legend.position = "right")
g_mapa_clusters <- ggplot(df_ACM, aes(x = CS1, y = CS2, color = Cluster, label = SG_UF)) +
geom_point(size = 3, alpha = 0.7) +
geom_text_repel(size = 3.5, color = "black", fontface = "bold") +
theme_minimal(base_size = 13) +
labs(
title = "Mapa Perceptual ‚Äî Segmenta√ß√£o dos Perfis de Eleitores com Defici√™ncia",
subtitle = "An√°lise de Correspond√™ncia M√∫ltipla (ACM) com K-Means Clustering (K = 3)",
x = "Dimens√£o 1",
y = "Dimens√£o 2"
) +
scale_color_brewer(palette = "Set2")
g_mapa_clusters <- ggplot(df_ACM, aes(x = CS1, y = CS2, color = Cluster, label = SG_UF)) +
geom_point(size = 3, alpha = 0.7) +
geom_text_repel(size = 3.5, color = "black", fontface = "bold") +
theme_minimal(base_size = 13) +
labs(
title = "Mapa Perceptual ‚Äî Segmenta√ß√£o dos Perfis de Eleitores com Defici√™ncia",
subtitle = "An√°lise de Correspond√™ncia M√∫ltipla (ACM) com K-Means Clustering (K = 3)",
x = "Dimens√£o 1",
y = "Dimens√£o 2"
) +
scale_color_brewer(palette = "Set2")
library(FactoMineR)
library(factoextra)
library(ggrepel)
install.packages("factoextra")
library(factoextra)
# Executa a ACM novamente (caso precise das coordenadas das vari√°veis)
acm_result <- MCA(dados_acm, graph = FALSE)
library(FactoMineR)
library(factoextra)
# Executa a ACM novamente (caso precise das coordenadas das vari√°veis)
acm_result <- MCA(dados_acm, graph = FALSE)
coord_var$Variable <- rownames(coord_var)
# Executa a ACM novamente (caso precise das coordenadas das vari√°veis)
acm_result <- acm
install.packages("factoextra")
library(factoextra)
# Executa a ACM novamente (caso precise das coordenadas das vari√°veis)
acm_result <- acm
# Executa a ACM novamente (caso precise das coordenadas das vari√°veis)
acm_result <- df_ACM
# Extrai coordenadas das vari√°veis
coord_var <- as.data.frame(acm_result$var$coord)
coord_var$Variable <- rownames(coord_var)
# Extrai coordenadas das observa√ß√µes (estados)
coord_ind <- as.data.frame(acm_result$ind$coord)
coord_ind$SG_UF <- dados_acm$SG_UF
# A fun√ß√£o para a cria√ß√£o da ACM pede que sejam utilizados "fatores"
dados_acm <- as.data.frame(unclass(dados_acm), stringsAsFactors=TRUE)
# Vamos gerar a ACM
ACM <- dudi.acm(dados_acm, scannf = FALSE)
# --- 24/08
getwd()
dados_acm<- read.csv("data/perfil_eleitor_red.csv", sep = ",", header = TRUE, stringsAsFactors = TRUE)
# Mostra as primeiras linhas do data frame
head(dados_acm)
# Mostra a estrutura do data frame
str(dados_acm)
# Padroniza os nomes (tudo mai√∫sculo)
names(dados_acm) <- toupper(names(dados_acm))
# Remove linhas com NA (caso existam)
dados_acm <- na.omit(dados_acm)
# Instala√ß√£o e carregamento dos pacotes utilizados
pacotes <- c("plotly",
"tidyverse",
"ggrepel",
"ggplot2",
"knitr", "kableExtra",
"sjPlot",
"FactoMineR",
"amap",
"ade4",
"readxl")
# Carregando todos
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# A fun√ß√£o para a cria√ß√£o da ACM pede que sejam utilizados "fatores"
dados_acm <- as.data.frame(unclass(dados_acm), stringsAsFactors=TRUE)
# Vamos gerar a ACM
ACM <- dudi.acm(dados_acm, scannf = FALSE)
# Analisando as vari√¢ncias de cada dimens√£o (tirando os autovalores)
perc_variancia <- (ACM$eig / sum(ACM$eig)) * 100
paste0(round(perc_variancia,2),"%")
# Quantidade de categorias por vari√°vel
quant_categorias <- apply(dados_acm,
MARGIN =  2,
FUN = function(x) nlevels(as.factor(x)))
df_ACM <- data.frame(ACM$c1, Vari√°vel = rep(names(quant_categorias),
quant_categorias))
# Plotando o mapa perceptual
grafico_acm <- df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Vari√°vel)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(
title = "Mapa Perceptual - An√°lise de Correspond√™ncia M√∫ltipla",
x = paste("Dimens√£o 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimens√£o 2:", paste0(round(perc_variancia[2], 2), "%"))
) +
theme_bw()
str(grafico_acm)
print(grafico_acm)
library(dplyr)
wss <- sapply(1:10, function(k) {
kmeans(df_ACM[, c("CS1", "CS2")], centers = k, nstart = 25)$tot.withinss
})
plot(1:10, wss, type = "b", pch = 19, frame = FALSE,
xlab = "N√∫mero de Clusters (k)", ylab = "Soma dos Erros Quadrados (WSS)",
main = "M√©todo do Cotovelo para defini√ß√£o de K")
set.seed(123)
ideal_clusters <- 3
kmeans_result <- kmeans(df_ACM[, c("CS1","CS2")], centers = ideal_clusters, nstart = 25)
df_ACM$Cluster <- as.factor(kmeans_result$cluster)
table(df_ACM$Cluster)
# --- Salvando o gr√°fico do m√©todo do cotovelo ---
# Garante que o diret√≥rio existe
if (!dir.exists("output")) dir.create("output")
# Abre o dispositivo gr√°fico corretamente
png(filename = "output/metodo_cotovelo.png", width = 900, height = 600, res = 120)
# Plota o gr√°fico
plot(
1:10, wss, type = "b", pch = 19, frame = FALSE,
xlab = "N√∫mero de Clusters (k)",
ylab = "Soma dos Erros Quadrados (WSS)",
main = "M√©todo do Cotovelo para defini√ß√£o de K"
)
# Fecha o dispositivo gr√°fico (gera o arquivo .png)
dev.off()
library(FactoMineR)
install.packages("factoextra")
install.packages("factoextra")
library(factoextra)
# Executa a ACM novamente (caso precise das coordenadas das vari√°veis)
acm_result <- ACM
# Extrai coordenadas das vari√°veis
coord_var <- as.data.frame(acm_result$c1)
coord_var$Variable <- rownames(coord_var)
# Extrai coordenadas das observa√ß√µes (estados)
coord_ind <- as.data.frame(acm_result$li)
if("SG_UF" %in% names(dados_acm)){
coord_ind$SG_UF <- dados_acm$SG_UF
}
if("Cluster" %in% names(df_ACM)){
coord_ind$Cluster <- df_ACM$Cluster
}
# --- 24/08
getwd()
dados_acm<- read.csv("data/perfil_eleitor_red.csv", sep = ",", header = TRUE, stringsAsFactors = TRUE)
# Mostra as primeiras linhas do data frame
head(dados_acm)
# Mostra a estrutura do data frame
str(dados_acm)
# Padroniza os nomes (tudo mai√∫sculo)
names(dados_acm) <- toupper(names(dados_acm))
# Remove linhas com NA (caso existam)
dados_acm <- na.omit(dados_acm)
# Carregando todos
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# Instala√ß√£o e carregamento dos pacotes utilizados
pacotes <- c("plotly",
"tidyverse",
"ggrepel",
"ggplot2",
"knitr", "kableExtra",
"sjPlot",
"FactoMineR",
"amap",
"ade4",
"readxl")
# Carregando todos
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# A fun√ß√£o para a cria√ß√£o da ACM pede que sejam utilizados "fatores"
dados_acm <- as.data.frame(unclass(dados_acm), stringsAsFactors=TRUE)
# Tabelas de conting√™ncia (todas apresentam associa√ß√£o com alguma vari√°vel?)
sjt.xtab(var.row = dados_acm $DS_TIPO_DEFICIENCIA,
var.col = dados_acm $DS_GENERO,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = dados_acm $DS_TIPO_DEFICIENCIA,
var.col = dados_acm $DS_FAIXA_ETARIA,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = dados_acm $DS_TIPO_DEFICIENCIA,
var.col = dados_acm $DS_RACA_COR,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = dados_acm $DS_TIPO_DEFICIENCIA,
var.col = dados_acm $DS_GRAU_ESCOLARIDADE,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = dados_acm $DS_TIPO_DEFICIENCIA,
var.col = dados_acm $DS_ESTADO_CIVIL,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = dados_acm $DS_TIPO_DEFICIENCIA,
var.col = dados_acm $SG_UF,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
sjt.xtab(var.row = dados_acm $DS_TIPO_DEFICIENCIA,
var.col = dados_acm $REGIAO,
show.exp = TRUE,
show.row.prc = TRUE,
show.col.prc = TRUE,
encoding = "UTF-8")
# Vamos gerar a ACM
ACM <- dudi.acm(dados_acm, scannf = FALSE)
# Analisando as vari√¢ncias de cada dimens√£o (tirando os autovalores)
perc_variancia <- (ACM$eig / sum(ACM$eig)) * 100
paste0(round(perc_variancia,2),"%")
# Quantidade de categorias por vari√°vel
quant_categorias <- apply(dados_acm,
MARGIN =  2,
FUN = function(x) nlevels(as.factor(x)))
df_ACM <- data.frame(ACM$c1, Vari√°vel = rep(names(quant_categorias),
quant_categorias))
# Plotando o mapa perceptual geral
grafico_acm <- df_ACM %>%
rownames_to_column() %>%
rename(Categoria = 1) %>%
ggplot(aes(x = CS1, y = CS2, label = Categoria, color = Vari√°vel)) +
geom_point() +
geom_label_repel() +
geom_vline(aes(xintercept = 0), linetype = "longdash", color = "grey48") +
geom_hline(aes(yintercept = 0), linetype = "longdash", color = "grey48") +
labs(
title = "Mapa Perceptual - An√°lise de Correspond√™ncia M√∫ltipla",
x = paste("Dimens√£o 1:", paste0(round(perc_variancia[1], 2), "%")),
y = paste("Dimens√£o 2:", paste0(round(perc_variancia[2], 2), "%"))
) +
theme_bw()
str(grafico_acm)
print(grafico_acm)
library(dplyr)
wss <- sapply(1:10, function(k) {
kmeans(df_ACM[, c("CS1", "CS2")], centers = k, nstart = 25)$tot.withinss
})
plot(1:10, wss, type = "b", pch = 19, frame = FALSE,
xlab = "N√∫mero de Clusters (k)", ylab = "Soma dos Erros Quadrados (WSS)",
main = "M√©todo do Cotovelo para defini√ß√£o de K")
set.seed(123)
ideal_clusters <- 3
kmeans_result <- kmeans(df_ACM[, c("CS1","CS2")], centers = ideal_clusters, nstart = 25)
df_ACM$Cluster <- as.factor(kmeans_result$cluster)
table(df_ACM$Cluster)
# 1Ô∏è‚É£ Extrai as coordenadas das observa√ß√µes (indiv√≠duos) da ACM
df_obs_coords <- as.data.frame(ACM$li)
colnames(df_obs_coords)[1:2] <- c("Axis1", "Axis2")
# 2Ô∏è‚É£ Adiciona identificador de linha para fazer o join
df_obs_coords <- df_obs_coords %>% tibble::rownames_to_column(var = "row_id")
# 3Ô∏è‚É£ Garante que a base original tamb√©m tenha o identificador
dados_acm <- dados_acm %>% tibble::rownames_to_column(var = "row_id")
# 4Ô∏è‚É£ Junta as coordenadas com as vari√°veis originais
df_obs <- dplyr::left_join(df_obs_coords, dados_acm, by = "row_id")
# 5Ô∏è‚É£ Reaplica o k-means nas coordenadas dos indiv√≠duos (Axis1 e Axis2)
set.seed(123)
k <- 3
kmeans_obs <- kmeans(df_obs[, c("Axis1", "Axis2")], centers = k, nstart = 25)
# 6Ô∏è‚É£ Adiciona a coluna de cluster no df_obs
df_obs$Cluster <- factor(kmeans_obs$cluster)
library(ggplot2)
library(ggrepel)
library(dplyr)
# Coordenadas das observa√ß√µes (estados)
coord_ind <- as.data.frame(ACM$li) %>%
tibble::rownames_to_column("row_id") %>%
mutate(SG_UF = dados_acm$SG_UF) %>%
left_join(df_obs %>% select(row_id, Cluster), by = "row_id")
# Coordenadas das vari√°veis
coord_var <- as.data.frame(ACM$c1) %>%
tibble::rownames_to_column("Categoria") %>%
mutate(dist = sqrt(CS1^2 + CS2^2)) %>%
arrange(desc(dist)) %>%
slice_head(n = 15)  # mostra s√≥ as 15 vari√°veis mais influentes
g_mapa_perceptual <- ggplot() +
# Pontos dos estados coloridos por cluster
geom_point(data = coord_ind, aes(x = Axis1, y = Axis2, color = Cluster), size = 2.8, alpha = 0.8) +
geom_text(data = coord_ind, aes(x = Axis1, y = Axis2, label = SG_UF, color = Cluster),
size = 3, fontface = "bold", show.legend = FALSE) +
# Setas e r√≥tulos das vari√°veis mais relevantes
geom_segment(data = coord_var, aes(x = 0, y = 0, xend = CS1, yend = CS2),
arrow = arrow(length = unit(0.15, "cm")), color = "gray60", alpha = 0.7) +
geom_text(data = coord_var, aes(x = CS1, y = CS2, label = Categoria),
color = "black", size = 3, fontface = "bold") +
# Linhas de refer√™ncia e tema
geom_vline(xintercept = 0, linetype = "dashed", color = "gray70") +
geom_hline(yintercept = 0, linetype = "dashed", color = "gray70") +
labs(
title = "Mapa Perceptual ‚Äî Perfis e Vari√°veis dos Eleitores com Defici√™ncia",
subtitle = "ACM combinada com K-Means Clustering (visualiza√ß√£o simplificada)",
x = paste0("Dimens√£o 1: ", round(perc_variancia[1], 2), "%"),
y = paste0("Dimens√£o 2: ", round(perc_variancia[2], 2), "%"),
color = "Cluster"
) +
scale_color_brewer(palette = "Set2") +
theme_minimal(base_size = 13)
# Salva o gr√°fico
ggsave("output/mapa_perceptual_clusters_interpretavel.png",
plot = g_mapa_perceptual, width = 10, height = 7, dpi = 300)
print(g_mapa_perceptual)
library(igraph)
library(ggraph)
# =====================================================
# # =====================================================
# üåå Mapa de Rede (Estilo Constela√ß√£o de Clusters)
# =====================================================
install.packages("igraph")
library(igraph)
library(ggraph)
# Cria base reduzida com coordenadas das observa√ß√µes
coord_rede <- coord_ind %>%
select(SG_UF, Axis1 = CS1, Axis2 = CS2, Cluster)
install.packages(c("ggraph", "tidygraph", "igraph", "dplyr"))
library(dplyr)
library(igraph)
library(ggraph)
library(tidygraph)
# Cria base reduzida com coordenadas das observa√ß√µes
coord_rede <- coord_ind %>%
select(SG_UF, Axis1 = CS1, Axis2 = CS2, Cluster)
